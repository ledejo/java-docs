"use strict";(self.webpackChunkjava_docs=self.webpackChunkjava_docs||[]).push([[9762],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,g=m["".concat(o,".").concat(u)]||m[u]||c[u]||i;return n?a.createElement(g,s(s({ref:t},d),{},{components:n})):a.createElement(g,s({ref:t},d))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[m]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6387:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={title:"Assoziativspeicher (Maps)",description:"",sidebar_position:280,tags:["maps"]},s=void 0,l={unversionedId:"documentation/maps",id:"documentation/maps",title:"Assoziativspeicher (Maps)",description:"",source:"@site/docs/documentation/maps.md",sourceDirName:"documentation",slug:"/documentation/maps",permalink:"/java-docs/documentation/maps",draft:!1,editUrl:"https://github.com/jappuccini/java-docs/tree/main/docs/documentation/maps.md",tags:[{label:"maps",permalink:"/java-docs/tags/maps"}],version:"current",sidebarPosition:280,frontMatter:{title:"Assoziativspeicher (Maps)",description:"",sidebar_position:280,tags:["maps"]},sidebar:"documentationSidebar",previous:{title:"Generische Programmierung",permalink:"/java-docs/documentation/generics"},next:{title:"Optionals",permalink:"/java-docs/documentation/optionals"}},o={},p=[],d={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unter einem Assoziativspeicher (Map) versteht man eine Menge zusammengeh\xf6riger Paare von Objekten. Das erste Objekt stellt dabei den Schl\xfcssel (Key), das zweite Objekt den Wert (Value) dar. Jeder Schl\xfcssel kann dabei nur einmal in einem Assoziativspeicher\nvorhanden sein. Aufgrund dieses Aufbaus werden Assoziativspeicher auch als W\xf6rterb\xfccher bezeichnet."),(0,r.kt)("mermaid",{value:"flowchart LR\n    subgraph Noten\n        direction LR\n        hans(Hans) -.-> g1((2.3))\n        peter(Peter) -.-> g2((1.7))\n        lisa(Lisa) -.-> g3((1.8))\n        max(Max) -.-> g4((4.2))\n    end"}),(0,r.kt)("p",null,"Um auf die Eintr\xe4ge, Schl\xfcssel und Werte eines Assoziativspeichers zugreifen k\xf6nnen, stellt die Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," die Methoden ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<Entry<K, V>> entrySet()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<K> keySet()")," und ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<V> values()")," zur Verf\xfcgung."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="MainClass.java" showLineNumbers',title:'"MainClass.java"',showLineNumbers:!0},'public class MainClass {\n\n  public static void main(String[] args) {\n\n    HashMap<Integer, String> foos = new HashMap<>();\n    foos.put(834, "Hans");\n    foos.put(269, "Peter");\n    foos.put(771, "Lisa");\n\n    for (Entry<Integer, String> entry : foos.entrySet()) {\n      System.out.println(entry.getKey());\n      System.out.println(entry.getValue());\n    }\n\n    for (Integer i : foos.keySet()) {\n      System.out.println(i);\n    }\n\n    for (String s : foos.values()) {\n      System.out.println(s);\n    }\n\n  }\n\n}\n')),(0,r.kt)("p",null,"Die Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap<K, V>")," implementiert den Assoziativspeicher in Form einer Hashtabelle. F\xfcr den Einsatz einer Hashtabelle ist es zwingend erforderlich, dass die Klasse, die den Schl\xfcssel bildet, die Methoden ",(0,r.kt)("inlineCode",{parentName:"p"},"int hashCode()")," und ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean equals(object: Object)"),"\ngem\xe4\xdf den entsprechenden Dokumentationskommentaren \xfcberschrieben hat. Im Gegensatz zu einem Bin\xe4rbaum liegen die Paare in einer Hashtabelle unsortiert vor."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Index"),(0,r.kt)("th",{parentName:"tr",align:null},"Schl\xfcssel"),(0,r.kt)("th",{parentName:"tr",align:null},"Wert"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"Hans"),(0,r.kt)("td",{parentName:"tr",align:null},"2.3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Peter"),(0,r.kt)("td",{parentName:"tr",align:null},"1.7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"13"),(0,r.kt)("td",{parentName:"tr",align:null},"Lisa"),(0,r.kt)("td",{parentName:"tr",align:null},"1.8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"14"),(0,r.kt)("td",{parentName:"tr",align:null},"Max"),(0,r.kt)("td",{parentName:"tr",align:null},"4.2")))),(0,r.kt)("p",null,"Die Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"TreeMap<K, V>")," implementiert den Assoziativspeicher in Form eines Bin\xe4rbaumes. Als Datenstruktur wird dabei ein balancierter Baum verwendet, d.h. spezielle Einf\xfcge- und L\xf6schoperationen stellen sicher, dass der Baum nicht zu einer linearen Liste\nentartet. Da die Paare in einem Bin\xe4rbaum sortiert vorliegen, ist es f\xfcr den Einsatz zwingend erforderlich, dass die Klasse, die den Schl\xfcssel bildet, die Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>")," implementiert hat. Alternativ kann dem Konstruktor der Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"TreeMap<K, V>"),"\nein Komparator f\xfcr den Schl\xfcssel mitgegeben werden."),(0,r.kt)("mermaid",{value:"flowchart TD\n    max --\x3e lisa\n    lisa --\x3e hans\n    max --\x3e peter\n\n    hans(Hans) -.-> g1((2.3))\n    peter(Peter) -.-> g2((1.7))\n    lisa(Lisa) -.-> g3((1.8))\n    max(Max) -.-> g4((4.2))"}))}c.isMDXComponent=!0}}]);
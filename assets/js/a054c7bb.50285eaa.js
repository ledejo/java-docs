"use strict";(self.webpackChunkjava_docs=self.webpackChunkjava_docs||[]).push([[2664],{3905:(e,a,n)=>{n.d(a,{Zo:()=>p,kt:()=>b});var s=n(7294);function t(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);a&&(s=s.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){t(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,s,t=function(e,a){if(null==e)return{};var n,s,t={},r=Object.keys(e);for(s=0;s<r.length;s++)n=r[s],a.indexOf(n)>=0||(t[n]=e[n]);return t}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)n=r[s],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(t[n]=e[n])}return t}var u=s.createContext({}),o=function(e){var a=s.useContext(u),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},p=function(e){var a=o(e.components);return s.createElement(u.Provider,{value:a},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return s.createElement(s.Fragment,{},a)}},d=s.forwardRef((function(e,a){var n=e.components,t=e.mdxType,r=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=o(n),d=t,b=c["".concat(u,".").concat(d)]||c[d]||m[d]||r;return n?s.createElement(b,i(i({ref:a},p),{},{components:n})):s.createElement(b,i({ref:a},p))}));function b(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var u in a)hasOwnProperty.call(a,u)&&(l[u]=a[u]);l.originalType=e,l[c]="string"==typeof e?e:t,i[1]=l;for(var o=2;o<r;o++)i[o]=n[o];return s.createElement.apply(null,i)}return s.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2863:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var s=n(7462),t=(n(7294),n(3905));const r={title:"(Dynamische) Polymorphie",description:"",sidebar_position:180,tags:["polymorphy"]},i=void 0,l={unversionedId:"documentation/polymorphy",id:"documentation/polymorphy",title:"(Dynamische) Polymorphie",description:"",source:"@site/docs/documentation/polymorphy.md",sourceDirName:"documentation",slug:"/documentation/polymorphy",permalink:"/java-docs/documentation/polymorphy",draft:!1,editUrl:"https://github.com/jappuccini/java-docs/tree/main/docs/documentation/polymorphy.md",tags:[{label:"polymorphy",permalink:"/java-docs/tags/polymorphy"}],version:"current",sidebarPosition:180,frontMatter:{title:"(Dynamische) Polymorphie",description:"",sidebar_position:180,tags:["polymorphy"]},sidebar:"documentationSidebar",previous:{title:"Vererbung",permalink:"/java-docs/documentation/inheritance"},next:{title:"Die Mutter aller Klassen",permalink:"/java-docs/documentation/object"}},u={},o=[{value:"Upcast",id:"upcast",level:2},{value:"Downcast",id:"downcast",level:2},{value:"Der instanceof-Operator",id:"der-instanceof-operator",level:2}],p={toc:o},c="wrapper";function m(e){let{components:a,...n}=e;return(0,t.kt)(c,(0,s.Z)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,t.kt)("p",null,"Unter (dynamischer) Polymorphie (griechisch f\xfcr Vielgestaltigkeit) versteht man, dass eine Referenzvariable zur Laufzeit durch Typumwandlung Referenzen auf Objekte unterschiedlicher Klassen besitzen kann und dass dadurch unterschiedliche Methodenimplementierungen aufgerufen\nwerden k\xf6nnen. Man spricht in diesem Zusammenhang auch vom ",(0,t.kt)("em",{parentName:"p"},"statischen Datentyp einer Referenzvariablen")," (der zur Designzeit festgelegt wird) und vom ",(0,t.kt)("em",{parentName:"p"},"dynamischen Datentyp einer Referenzvariablen")," (der zur Laufzeit zugewiesen wird). Der statische Typ legt\nfest, welche Methoden aufgerufen werden k\xf6nnen, der dynamische, welche Methodenimplementierung aufgerufen wird. Die Typumwandlung von der abgeleiteten Unterklasse zur Oberklasse bezeichnet man als ",(0,t.kt)("em",{parentName:"p"},"Upcast"),", die R\xfcckumwandlung als ",(0,t.kt)("em",{parentName:"p"},"Downcast"),"."),(0,t.kt)("h2",{id:"upcast"},"Upcast"),(0,t.kt)("p",null,"Beim Upcast wird die Objektreferenz der Unterklasse in eine Objektreferenz der Oberklasse umgewandelt."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SuperClass.java" showLineNumbers',title:'"SuperClass.java"',showLineNumbers:!0},"public class SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SubClass.java" showLineNumbers',title:'"SubClass.java"',showLineNumbers:!0},"public class SubClass extends SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="MainClass.java" showLineNumbers',title:'"MainClass.java"',showLineNumbers:!0},"public class MainClass {\n\n  public static void main(String[] args) {\n    SuperClass superClass;\n    SubClass subClass = new SubClass();\n    superClass = subClass; // Upcast\n  }\n\n}\n")),(0,t.kt)("h2",{id:"downcast"},"Downcast"),(0,t.kt)("p",null,"Beim Downcast wird die Objektreferenz der Oberklasse in eine Objektreferenz der Unterklasse umgewandelt. Im Gegensatz zum Upcast muss bei einem Downcast der Typ explizit angegeben werden. Der Downcast einer nicht zuweisungskompatiblen Referenz f\xfchrt zu einer\n",(0,t.kt)("inlineCode",{parentName:"p"},"ClassCastException"),"."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SuperClass.java" showLineNumbers',title:'"SuperClass.java"',showLineNumbers:!0},"public class SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SubClass.java" showLineNumbers',title:'"SubClass.java"',showLineNumbers:!0},"public class SubClass extends SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="MainClass.java" showLineNumbers',title:'"MainClass.java"',showLineNumbers:!0},"public class MainClass {\n\n  public static void main(String[] args) {\n    SuperClass superClass;\n    SubClass subClass = new SubClass();\n    superClass = subClass; // Upcast\n    subClass = (SubClass) superClass; // Downcast\n  }\n\n}\n")),(0,t.kt)("h2",{id:"der-instanceof-operator"},"Der instanceof-Operator"),(0,t.kt)("p",null,"Mit dem Operator ",(0,t.kt)("inlineCode",{parentName:"p"},"instanceof")," kann zur Laufzeit gepr\xfcft werden, ob eine Objektreferenz zuweisungskompatibel zu einer Klasse ist. Eine Objektreferenz ist dann zuweisungskompatibel zu einer Klasse, wenn die Klasse des referenzierten Objektes in einer\nVererbungsbeziehung zur Klasse steht."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SuperClass.java" showLineNumbers',title:'"SuperClass.java"',showLineNumbers:!0},"public class SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SubClass.java" showLineNumbers',title:'"SubClass.java"',showLineNumbers:!0},"public class SubClass extends SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="MainClass.java" showLineNumbers',title:'"MainClass.java"',showLineNumbers:!0},"public class MainClass {\n\n  public static void main(String[] args) {\n    SuperClass superClass;\n    SubClass subClass = new SubClass();\n    superClass = subClass; // Upcast\n    if (superClass instanceof SubClass) {\n      subClass = (SubClass) superClass; // Downcast\n    }\n  }\n\n}\n")),(0,t.kt)("p",null,"Seit Java 16 erm\xf6glicht der Mustervergleich bei ",(0,t.kt)("inlineCode",{parentName:"p"},"instanceof")," das Vermeiden notwendiger Typumwandlungen und sorgt gleichzeitig f\xfcr eine sicherere Programmierung."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SuperClass.java" showLineNumbers',title:'"SuperClass.java"',showLineNumbers:!0},"public class SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="SubClass.java" showLineNumbers',title:'"SubClass.java"',showLineNumbers:!0},"public class SubClass extends SuperClass {\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="MainClass.java" showLineNumbers',title:'"MainClass.java"',showLineNumbers:!0},"public class MainClass {\n\n  public static void main(String[] args) {\n    SuperClass superClass;\n    SubClass subClass = new SubClass();\n    superClass = subClass; // Upcast\n    if (superClass instanceof SubClass s) { // Downcast\n    }\n  }\n\n}\n")))}m.isMDXComponent=!0}}]);